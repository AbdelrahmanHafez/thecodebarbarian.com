<html><head><script type="text/javascript">var _sf_startpt=(new Date()).getTime()
</script><title>Basic Functional Programming With Async/Await | www.thecodebarbarian.com</title><meta name="viewport" content="width=device-width, initial-scale=1"/><link href="//maxcdn.bootstrapcdn.com/bootstrap/3.2.0/css/bootstrap.min.css" rel="stylesheet" type="text/css"/><link href="//fonts.googleapis.com/css?family=Source+Sans+Pro:200,300,400,600" rel="stylesheet" type="text/css"/><link href="//fonts.googleapis.com/css?family=Merriweather:400,400italic,600,700" rel="stylesheet" type="text/css"/><link href="//maxcdn.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css" rel="stylesheet"/><link href="/style/style.css" rel="stylesheet" type="text/css"/><link href="/style/github.css" rel="stylesheet" type="text/css"/><script href="http://code.jquery.com/jquery-2.1.1.min.js" type="text/javascript"></script><script href="//maxcdn.bootstrapcdn.com/bootstrap/3.2.0/js/bootstrap.min.js" type="text/javascript"></script><script href="/javascript/sidebar.js" type="text/javascript"></script><meta property="og:title" content="Basic Functional Programming With Async/Await"/><meta property="og:url" content="http://www.thecodebarbarian.com/basic-functional-programming-with-async-await"/><meta property="og:image" content="http://i.imgur.com/pNQZG9E.jpg"/><meta property="og:site_name" content="The Code Barbarian"/></head><body><div class="navbar social-links hidden-sm hidden-xs"><div class="container"><ul class="nav navbar-nav navbar-right"><li><a href="http://www.twitter.com/code_barbarian">twitter</a></li><li><a href="http://www.github.com/vkarpov15">github</a></li><li><a href="http://thecodebarbarian.com/feed.xml">rss</a></li></ul></div></div><div id="nav" class="navbar"><div class="container"><div class="navbar-header"><a href="/" class="navbar-brand big-brand"><img src="/images/Barbarian_Head.png" class="logo"/><span class="site-name">The Code Barbarian  </span></a></div><div id="home-nav-mobile" class="navbar-right collapse navbar-collapse"><ul class="nav navbar-nav"><li><a href="/tag/mongodb.html">MongoDB</a></li><li><a href="/tag/angularjs.html">AngularJS</a></li><li><a href="/tag/nodejs.html">NodeJS</a></li><li><a href="/tag/paleo.html">Paleo</a></li><li class="hidden-md hidden-lg"><a href="#">@code_barbarian</a></li><li class="hidden-md hidden-lg"><a href="#">TCB Github</a></li><li class="hidden-md hidden-lg"><a href="#">TCB Facebook</a></li></ul></div></div></div><div class="container-fluid"><div id="desktop-right-bar" class="col-lg-3 col-lg-offset-9 right-bar"><div class="right-bar-content-slider pull-right"><div class="row search-container"><div class="col-lg-12"><div class="form-group"></div><label>Search</label><form onsubmit="window.location.href = 'https://www.google.im/search?q=' + encodeURIComponent(document.getElementById('searchQ').value) + '+site:thecodebarbarian.com'; return false;"><div class="input-group"><input id="searchQ" type="text" class="form-control"/><div class="input-group-addon search-button"><i class="fa fa-search"></i></div></div></form></div></div><div class="row recent-posts right-bar-group"><div class="col-lg-12 books"><div><a href="http://es2015generators.com"><img src="https://i.imgur.com/xvGNKlr.png"/></a></div><div><a href="https://www.amazon.com/gp/product/1118832078/ref=as_li_tl?ie=UTF8&amp;camp=1789&amp;creative=9325&amp;creativeASIN=1118832078&amp;linkCode=as2&amp;tag=codebarbarian-20&amp;linkId=6961294e8d5bcaf24a7b3319599fae92"><img src="http://i.imgur.com/NjE7AN9.png"/></a></div><div><script type="text/javascript" src="//cdn.carbonads.com/carbon.js?zoneid=1673&amp;serve=C6AILKT&amp;placement=thecodebarbariancom" id="_carbonads_js"></script></div></div></div><div class="row recent-posts right-bar-group"><div class="col-lg-12"><p class="right-bar-label">All Time Most Popular </p><ul class="list-unstyled"><li class="right-bar-li"><a href="http://thecodebarbarian.com/2015/01/24/angularjs-interceptors.html">An 80/20 Guide to AngularJS HTTP Interceptors</a></li><li class="right-bar-li"><a href="http://thecodebarbarian.com/2015/01/17/angularjs-loopback.html">Creating REST APIs and Clients with LoopBack and AngularJS</a></li><li class="right-bar-li"><a href="http://thecodebarbarian.com/cursors-in-mongoose-45">Cursors in Mongoose 4.5</a></li><li class="right-bar-li"><a href="http://thecodebarbarian.com/2015/03/20/callback-hell-is-a-myth">Callback Hell is a Myth</a></li><li class="right-bar-li"><a href="http://thecodebarbarian.com/2015/06/12/testing-angularjs-directives">Testing AngularJS Directives</a></li></ul></div></div></div></div></div><div id="mobile-sharing-options" class="container-fluid hidden-sm hidden-md hidden-lg"><div class="row"><div class="col-lg-12"><div class="post-sharing-options"><div class="row"><div class="col-xs-3 twitter-share sharing-option"><a href="https://twitter.com/share?url=http%3A%2F%2Fwww.thecodebarbarian.com%2Fbasic-functional-programming-with-async-await&amp;via=code_barbarian" class="social"><i class="fa fa-twitter"></i></a></div><div class="col-xs-3 facebook-share sharing-option"><a href="https://www.facebook.com/sharer/sharer.php?u=http%3A%2F%2Fwww.thecodebarbarian.com%2F%2Fbasic-functional-programming-with-async-await" class="social"><i class="fa fa-facebook"></i></a></div><div class="col-xs-3 google-share sharing-option"><a href="https://plus.google.com/share?url=http%3A%2F%2Fwww.thecodebarbarian.com%2F%2Fbasic-functional-programming-with-async-await" class="social"><i class="fa fa-google-plus"></i></a></div><div class="col-xs-3 comment sharing-option"><a href="#disqus_thread" class="social"><i class="fa fa-comment"></i></a></div></div></div></div></div></div><div id="desktop-sharing-options" class="post-sharing-options hidden-xs pull-left"><ul class="list-unstyled"><li class="twitter-share"><a href="https://twitter.com/share?url=http%3A%2F%2Fwww.thecodebarbarian.com%2Fbasic-functional-programming-with-async-await&amp;via=code_barbarian" class="social"><i class="fa fa-twitter sharing-option"></i></a></li><li class="facebook-share"><a href="https://www.facebook.com/sharer/sharer.php?u=http%3A%2F%2Fwww.thecodebarbarian.com%2F%2Fbasic-functional-programming-with-async-await" class="social"><i class="fa fa-facebook sharing-option"></i></a></li><li class="google-share"><a href="https://plus.google.com/share?url=http%3A%2F%2Fwww.thecodebarbarian.com%2F%2Fbasic-functional-programming-with-async-await" class="social"><i class="fa fa-google-plus sharing-option"></i></a></li></ul></div><div class="container"><div class="col-lg-9 post-text"><div class="row"><div class="title-byline-container"><h1 class="post-title">Basic Functional Programming With Async/Await </h1><div class="credits"><span class="byline">by Valeri Karpov</span><span class="byhandle"><a href="http://www.twitter.com/code_barbarian">@code_barbarian</a></span><span class="bydate">April 20, 2017</span></div></div></div><div class="post-body-text-container"><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function">Async/await</a> makes it easy to <a href="http://thecodebarbarian.com/common-async-await-design-patterns-in-node.js.html">integrate asynchronous behavior with imperative constructs like for loops, if statements, and try/catch blocks</a>. Unfortunately, it doesn&#39;t do the same for functional constructs like <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach"><code>forEach</code></a>, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map"><code>map</code></a>, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce"><code>reduce</code></a>, and <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter"><code>filter</code></a>. Using these constructs with async functions leads to behavior that can seem downright baffling. In this article, I&#39;ll show you some common gotchas for async functions with JavaScript&#39;s built-in functional array methods and how to work around them.</p>
<p><em>Note: the below code is only tested on Node v7.6.0. Furthermore, the below code is only intended to be a thought experiment and a didactic example. I wouldn&#39;t recommend using it in production.</em></p>
<h2 id="motivation-and-foreach-">Motivation and <code>forEach</code></h2>
<p>In synchronous land, <code>forEach()</code> executes a function for each element of the array in order. For example, the below script is guaranteed to print 0-9:</p>
<pre><code class="lang-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">print</span>(<span class="hljs-params">n</span>) </span>{
  <span class="hljs-built_in">console</span>.log(n);
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params"></span>) </span>{
  [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>].forEach(print);
}

test();
</code></pre>
<p>Unfortunately, things get more subtle with async functions. The below script will print 0-9 in reverse order!</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">print</span>(<span class="hljs-params">n</span>) </span>{
  <span class="hljs-comment">// Wait 1 second before printing 0, 0.9 seconds before printing 1, etc.</span>
  <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(resolve =&gt; setTimeout(() =&gt; resolve(), <span class="hljs-number">1000</span> - n * <span class="hljs-number">100</span>));
  <span class="hljs-comment">// Will usually print 9, 8, 7, 6, 5, 4, 3, 2, 1, 0 but order is not strictly</span>
  <span class="hljs-comment">// guaranteed.</span>
  <span class="hljs-built_in">console</span>.log(n);
}

<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params"></span>) </span>{
  [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>].forEach(print);
}

test();
</code></pre>
<p>Even though both functions are async, Node.js won&#39;t wait for the first <code>print()</code> call to finish before executing the next one! Can you just add an <code>await</code>?</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-comment">// SyntaxError: Unexpected identifier</span>
  [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>].forEach(n =&gt; { <span class="hljs-keyword">await</span> print(n); });
}
</code></pre>
<p>Nope, <a href="http://knowyourmeme.com/memes/i-can-t-let-you-do-that-starfox">can&#39;t let you do that Starfox</a>, that&#39;s a <code>SyntaxError</code>, because <code>await</code> must <strong>always</strong> be in an <code>async</code> function. At this point, you can just give up and use <a href="https://www.npmjs.com/package/promise-series">the non-standard <code>Promise.series()</code> function</a>. But, if you remember that <code>async</code> functions are just functions that return promises, you can use promise chaining and <code>.reduce()</code> your way into getting an in-order <code>forEach()</code>.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">print</span>(<span class="hljs-params">n</span>) </span>{
  <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(resolve =&gt; setTimeout(() =&gt; resolve(), <span class="hljs-number">1000</span> - n * <span class="hljs-number">100</span>));
  <span class="hljs-built_in">console</span>.log(n);
}

<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-comment">// This is where the magic happens. Each `print()` call returns a promise,</span>
  <span class="hljs-comment">// so calling `then()` chains them together in order and prints 0-9 in order.</span>
  <span class="hljs-keyword">await</span> [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>].
    reduce((promise, n) =&gt; promise.then(() =&gt; print(n)), <span class="hljs-built_in">Promise</span>.resolve());
}

test();
</code></pre>
<p>You can also wrap this functionality into a handy <code>forEachAsync()</code> function:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">print</span>(<span class="hljs-params">n</span>) </span>{
  <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(resolve =&gt; setTimeout(() =&gt; resolve(), <span class="hljs-number">1000</span> - n * <span class="hljs-number">100</span>));
  <span class="hljs-built_in">console</span>.log(n);
}

<span class="hljs-built_in">Array</span>.prototype.forEachAsync = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">fn</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.reduce((promise, n) =&gt; promise.then(() =&gt; fn(n)), <span class="hljs-built_in">Promise</span>.resolve());
};

<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">await</span> [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>].forEachAsync(print);
}

test();
</code></pre>
<h2 id="chaining-with-map-and-filter-">Chaining with <code>map()</code> and <code>filter()</code></h2>
<p>One big advantage of JavaScript&#39;s functional array constructs is chaining. Suppose you&#39;re given an array of ids and you want to pull the documents that correspond to those ids, filter out the ones that are already in another database, and save all of those. You can do this without any functional primitives, but it will involve a lot of intermediate values.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> { MongoClient } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'mongodb'</span>);

<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">copy</span>(<span class="hljs-params">ids, db1, db2</span>) </span>{
  <span class="hljs-comment">// Find all docs from db1</span>
  <span class="hljs-keyword">const</span> fromDb1 = <span class="hljs-keyword">await</span> db1.collection(<span class="hljs-string">'Test'</span>).find({ _id: { $<span class="hljs-keyword">in</span>: ids } }).sort({ _id: <span class="hljs-number">1</span> }).toArray();
  <span class="hljs-comment">// And db2</span>
  <span class="hljs-keyword">const</span> fromDb2 = <span class="hljs-keyword">await</span> db2.collection(<span class="hljs-string">'Test'</span>).find({ _id: { $<span class="hljs-keyword">in</span>: ids } }).sort({ _id: <span class="hljs-number">1</span> }).toArray();

  <span class="hljs-comment">// Find all docs from db1 that aren't in db2</span>
  <span class="hljs-keyword">const</span> toInsert = [];
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> doc <span class="hljs-keyword">of</span> fromDb1) {
    <span class="hljs-keyword">if</span> (!fromDb2.find(_doc =&gt; _doc._id === doc._id)) {
      toInsert.push(doc);
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Insert'</span>, doc);
    }
  }
  <span class="hljs-comment">// And insert all of them</span>
  <span class="hljs-keyword">await</span> db2.collection(<span class="hljs-string">'Test'</span>).insertMany(toInsert);
}

<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> db1 = <span class="hljs-keyword">await</span> MongoClient.connect(<span class="hljs-string">'mongodb://localhost:27017/db1'</span>);
  <span class="hljs-keyword">const</span> db2 = <span class="hljs-keyword">await</span> MongoClient.connect(<span class="hljs-string">'mongodb://localhost:27017/db2'</span>);
  <span class="hljs-keyword">await</span> db1.dropDatabase();
  <span class="hljs-keyword">await</span> db2.dropDatabase();

  <span class="hljs-keyword">const</span> docs = [
    { _id: <span class="hljs-number">1</span> },
    { _id: <span class="hljs-number">2</span> },
    { _id: <span class="hljs-number">3</span> },
    { _id: <span class="hljs-number">4</span> }
  ];

  <span class="hljs-keyword">await</span> db1.collection(<span class="hljs-string">'Test'</span>).insertMany(docs);
  <span class="hljs-comment">// Only insert docs with _id 2 and 4 into db2</span>
  <span class="hljs-keyword">await</span> db2.collection(<span class="hljs-string">'Test'</span>).insertMany(docs.filter(doc =&gt; doc._id % <span class="hljs-number">2</span> === <span class="hljs-number">0</span>));

  <span class="hljs-keyword">await</span> copy(docs.map(doc =&gt; doc._id), db1, db2);
}

test();
</code></pre>
<p>Functional would make this a lot cleaner - you&#39;d just need <code>ids.map().filter().forEach()</code>, but each of those <code>map()</code>, <code>filter()</code>, and <code>each()</code> need to handle async functions. We already have <code>forEachAsync()</code>, implementing <code>mapAsync()</code> and <code>filterAsync()</code> is similar:</p>
<pre><code class="lang-javascript"><span class="hljs-built_in">Array</span>.prototype.mapAsync = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">fn</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.all(<span class="hljs-keyword">this</span>.map(fn));
};

<span class="hljs-built_in">Array</span>.prototype.filterAsync = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">fn</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.mapAsync(fn).then(_arr =&gt; <span class="hljs-keyword">this</span>.filter((v, i) =&gt; !!_arr[i]));
};
</code></pre>
<p>However, now we get to the problem of chaining. How do you chain together <code>mapAsync()</code> and <code>filterAsync()</code>? You could use <code>.then()</code> but that would not be quite as neat. Instead, you can create an <code>AsyncArray</code> class that represents a Promise that will eventually return an array, and attach <code>mapAsync</code>, <code>filterAsync</code>, and <code>forEachAsync</code> as class methods:</p>
<pre><code class="lang-javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AsyncArray</span> </span>{
  <span class="hljs-keyword">constructor</span>(promise) {
    <span class="hljs-keyword">this</span>.$promise = promise || <span class="hljs-built_in">Promise</span>.resolve();
  }

  then(resolve, reject) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> AsyncArray(<span class="hljs-keyword">this</span>.$promise.then(resolve, reject));
  }

  <span class="hljs-keyword">catch</span>(reject) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.then(<span class="hljs-literal">null</span>, reject);
  }

  mapAsync(fn) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.then(arr =&gt; <span class="hljs-built_in">Promise</span>.all(arr.map(fn)));
  }

  filterAsync(fn) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> AsyncArray(<span class="hljs-built_in">Promise</span>.all([<span class="hljs-keyword">this</span>, <span class="hljs-keyword">this</span>.mapAsync(fn)]).then(([arr, _arr]) =&gt; arr.filter((v, i) =&gt; !!_arr[i])));
  }

  forEachAsync(fn) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.then(arr =&gt; arr.reduce((promise, n) =&gt; promise.then(() =&gt; fn(n)), <span class="hljs-built_in">Promise</span>.resolve()));
  }
}
</code></pre>
<p>With this <code>AsyncArray</code> class, you chain <code>mapAsync()</code>, <code>filterAsync()</code>, and <code>forEachAsync()</code> since each of these helper methods returns an <code>AsyncArray</code>. Here&#39;s how it looks with the previous MongoDB example:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">copy</span>(<span class="hljs-params">ids, db1, db2</span>) </span>{
  <span class="hljs-keyword">new</span> AsyncArray(<span class="hljs-built_in">Promise</span>.resolve(ids)).
    mapAsync(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">_id</span>) </span>{
      <span class="hljs-keyword">return</span> db1.collection(<span class="hljs-string">'Test'</span>).findOne({ _id });
    }).
    filterAsync(<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">doc</span>) </span>{
      <span class="hljs-keyword">const</span> _doc = <span class="hljs-keyword">await</span> db2.collection(<span class="hljs-string">'Test'</span>).findOne({ _id: doc._id });
      <span class="hljs-keyword">return</span> !_doc;
    }).
    forEachAsync(<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">doc</span>) </span>{
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Insert'</span>, doc);
      <span class="hljs-keyword">await</span> db2.collection(<span class="hljs-string">'Test'</span>).insertOne(doc);
    }).
    <span class="hljs-keyword">catch</span>(error =&gt; <span class="hljs-built_in">console</span>.error(error));
}

<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> db1 = <span class="hljs-keyword">await</span> MongoClient.connect(<span class="hljs-string">'mongodb://localhost:27017/db1'</span>);
  <span class="hljs-keyword">const</span> db2 = <span class="hljs-keyword">await</span> MongoClient.connect(<span class="hljs-string">'mongodb://localhost:27017/db2'</span>);
  <span class="hljs-keyword">await</span> db1.dropDatabase();
  <span class="hljs-keyword">await</span> db2.dropDatabase();

  <span class="hljs-keyword">const</span> docs = [
    { _id: <span class="hljs-number">1</span> },
    { _id: <span class="hljs-number">2</span> },
    { _id: <span class="hljs-number">3</span> },
    { _id: <span class="hljs-number">4</span> }
  ];

  <span class="hljs-keyword">await</span> db1.collection(<span class="hljs-string">'Test'</span>).insertMany(docs);
  <span class="hljs-comment">// Only insert docs with _id 2 and 4 into db2</span>
  <span class="hljs-keyword">await</span> db2.collection(<span class="hljs-string">'Test'</span>).insertMany(docs.filter(doc =&gt; doc._id % <span class="hljs-number">2</span> === <span class="hljs-number">0</span>));

  <span class="hljs-keyword">await</span> copy(docs.map(doc =&gt; doc._id), db1, db2);
}

test();
</code></pre>
<h2 id="wrapping-up-with-reduce-">Wrapping Up with <code>reduce()</code></h2>
<p>Now that you have <code>mapAsync()</code>, <code>filterAsync()</code>, and <code>forEachAsync()</code>, why not go all the way and implement <code>reduceAsync()</code> too?</p>
<pre><code class="lang-javascript">  reduceAsync(fn, initial) {
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.resolve(initial).then(cur =&gt; {
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.forEachAsync(<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">v, i</span>) </span>{
        cur = <span class="hljs-keyword">await</span> fn(cur, v, i);
      }).then(() =&gt; cur);
    });
  }
</code></pre>
<p>Here&#39;s how to use <code>reduceAsync()</code>:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> db = <span class="hljs-keyword">await</span> MongoClient.connect(<span class="hljs-string">'mongodb://localhost:27017/test'</span>);
  <span class="hljs-keyword">await</span> db.dropDatabase();

  <span class="hljs-keyword">const</span> docs = [
    { _id: <span class="hljs-number">1</span>, name: <span class="hljs-string">'Axl'</span> },
    { _id: <span class="hljs-number">2</span>, name: <span class="hljs-string">'Slash'</span> },
    { _id: <span class="hljs-number">3</span>, name: <span class="hljs-string">'Duff'</span> },
    { _id: <span class="hljs-number">4</span>, name: <span class="hljs-string">'Izzy'</span> },
    { _id: <span class="hljs-number">5</span>, name: <span class="hljs-string">'Adler'</span> }
  ];

  <span class="hljs-keyword">await</span> db.collection(<span class="hljs-string">'People'</span>).insertMany(docs);

  <span class="hljs-keyword">const</span> ids = docs.map(doc =&gt; doc._id);

  <span class="hljs-keyword">const</span> nameToId = <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> AsyncArray(<span class="hljs-built_in">Promise</span>.resolve(ids)).
    reduceAsync(<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">cur, _id</span>) </span>{
      <span class="hljs-keyword">const</span> doc = <span class="hljs-keyword">await</span> db.collection(<span class="hljs-string">'People'</span>).findOne({ _id });
      cur[doc.name] = doc._id;
      <span class="hljs-keyword">return</span> cur;
    }, {});
  <span class="hljs-built_in">console</span>.log(nameToId);
}

test();
</code></pre>
<p>Overall, using async functions with <code>map()</code>, <code>filter()</code>, <code>reduce()</code>, and <code>forEach()</code> is possible, but requires custom functions and sophisticated promise chaining. I&#39;m sure somebody will come out with a library that makes working with promise arrays seamless, and I look forward to seeing it. Functional programming primitives make synchronous array operations clean and elegant, and remove a lot of wasteful intermediary values via chaining. Adding helpers that can operate on promises that resolve to arrays opens up some exciting possibilities.</p>
<p><em>Async/await is powerful, but if you&#39;re stuck using Node.js 4.x or 6.x because of LTS (especially since <a href="https://github.com/nodejs/CTC/issues/99">Node.js 8 is delayed</a>), you can still use similar functional programming patterns using ES6 generators and <a href="http://npmjs.org/package/co">co</a>. If you&#39;re looking for a much deeper dive into co, including how to write your own co replacement from scratch, check out my ebook, <a href="http://es2015generators.com/">The 80/20 Guide to ES2015 Generators</a></em></p>
<p><a href="http://es2015generators.com"><img width="200" src="http://i.imgur.com/iBT2ZEw.png"/></a></p>
</div><div style="color: #666666; border-top: 1px dashed #666666; margin: 25px; text-align: center; padding-top: 10px"><em>Found a typo or error? Open up a pull request! This post is
available as markdown on&nbsp;<a href="https://github.com/vkarpov15/thecodebarbarian.com/blob/master/lib/posts/20170420_async_fp.md">Github</a></em></div><div id="disqus_thread"></div><script type="text/javascript">/* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
var disqus_shortname = 'codebarbarian'; // required: replace example with your forum shortname

/* * * DON'T EDIT BELOW THIS LINE * * */
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript><a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a></div></div><div style="padding-bottom: 100px">&nbsp;</div><script type="text/javascript">!function(){var analytics=window.analytics=window.analytics||[];if(!analytics.initialize)if(analytics.invoked)window.console&&console.error&&console.error("Segment snippet included twice.");else{analytics.invoked=!0;analytics.methods=["trackSubmit","trackClick","trackLink","trackForm","pageview","identify","group","track","ready","alias","page","once","off","on"];analytics.factory=function(t){return function(){var e=Array.prototype.slice.call(arguments);e.unshift(t);analytics.push(e);return analytics}};for(var t=0;t<analytics.methods.length;t++){var e=analytics.methods[t];analytics[e]=analytics.factory(e)}analytics.load=function(t){var e=document.createElement("script");e.type="text/javascript";e.async=!0;e.src=("https:"===document.location.protocol?"https://":"http://")+"cdn.segment.com/analytics.js/v1/"+t+"/analytics.min.js";var n=document.getElementsByTagName("script")[0];n.parentNode.insertBefore(e,n)};analytics.SNIPPET_VERSION="3.0.1";
  analytics.load("5DErrxzVhprg8sNh8xaiKDR6dNa7yGTI");
  analytics.page()
}}();</script><script type="text/javascript">analytics.track('opened post',
  { title: "Basic Functional Programming With Async/Await", time: new Date() });
  </script></body></html>